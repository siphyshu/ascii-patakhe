<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Patakhe! ðŸ§¨</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }
        
        #viewport {
            position: relative;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            user-select: none;
            font-size: 18px;
            line-height: 1;
            will-change: transform, opacity;
        }
        
        .rocket {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            user-select: none;
            font-size: 20px;
            line-height: 1;
            will-change: transform, opacity;
        }
        
        .star {
            position: absolute;
            color: white;
            pointer-events: none;
            user-select: none;
            font-size: 12px;
            animation: twinkle 3s ease-in-out infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        #launchBtn:hover {
            transform: scale(1.05);
        }
        
        #launchBtn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="flex flex-col min-h-screen pb-8">
    <!-- Fireworks Viewport (Full Screen) -->
    <div id="viewport" class="flex-1 bg-black relative rounded-[50px] overflow-hidden mb-8">
    </div>
    
    <!-- Bottom Control Panel (Earth's horizon curve) -->
    <div class="px-8 py-8 flex flex-col items-center justify-center gap-4" style="border-radius: 50% 50% 0 0 / 120px 120px 0 0;">
        <!-- Launch Button -->
        <button id="launchBtn" class="px-10 py-4 bg-white text-black font-bold text-lg hover:bg-gray-200 transition-all duration-200 cursor-pointer">
            Launch Patakha!
        </button>
        
        <!-- Counter -->
        <div id="counter" class="text-gray-400 text-sm font-mono">
            PATAKHE LAUNCHED: <span id="count" class="text-white">0</span>
        </div>
    </div>

    <script>
        const viewport = document.getElementById('viewport');
        const launchBtn = document.getElementById('launchBtn');
        const countDisplay = document.getElementById('count');
        
        let fireworks = [];
        let fireworkCount = 0;
        let animationId = null;
        let lastTs = performance.now();
        
        // Create twinkling stars
        function createStars() {
            const starCount = 100;
            const starChars = ['.', '*', 'Â·', 'Â°', '+'];
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = starChars[Math.floor(Math.random() * starChars.length)];
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 80 + '%'; // Keep in top 80% of screen
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                viewport.appendChild(star);
            }
        }
        
        createStars();
        
        // DOM element pool for performance
        const elementPool = {
            pool: [],
            maxSize: 300,
            get(char, cls) {
                const el = this.pool.pop() || document.createElement('div');
                el.className = cls || 'particle';
                el.textContent = char;
                el.style.display = '';
                // Reset transform and opacity for reused elements
                el.style.transform = '';
                el.style.opacity = '1';
                return el;
            },
            release(el) {
                if (this.pool.length < this.maxSize) {
                    el.style.display = 'none';
                    this.pool.push(el);
                } else {
                    // Pool full, actually remove
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                }
            }
        };
        
        const colors = [
            '#ff0066', // hot pink (vivid)
            '#ffcc00', // bright gold (Diwali)
            '#ff6600', // deep orange (warm)
            '#ff3333', // bright red (classic)
            '#00ffff', // cyan (vivid)
            '#9966ff', // purple (classic firework)
            '#ffffff', // pure white
            '#ff9900', // amber (warm)
            '#66ffcc', // mint (vivid)
            '#ffdd00', // golden yellow (Diwali)
        ];
        
        class Firework {
            constructor(startX, explosionType = null, color = null) {
                this.id = Date.now() + Math.random();
                this.startX = startX;
                this.x = startX;
                this.y = viewport.clientHeight;
                
                // Minecraft-inspired physics
                this.vy = -9; // Initial vertical velocity (upward, faster now)
                this.vx = (Math.random() - 0.5) * 0.4; // Small random horizontal velocity
                
                // Target explosion height (position-based, relative to viewport)
                const explosionHeightPercent = Math.random() * 0.25 + 0.10; // Explode at 10-35% from top
                this.targetY = viewport.clientHeight * explosionHeightPercent;
                this.color = color || colors[Math.floor(Math.random() * colors.length)];
                
                // Choose explosion type (can be overridden by debug panel)
                this.explosionType = explosionType || ['peony', 'palm'][Math.floor(Math.random() * 2)];
                
                this.phase = 'launch'; // 'launch' or 'explode'
                this.particles = [];
                this.trail = [];
                this.trailElements = []; // Store trail elements for reuse
                this.exploded = false;
                this.dead = false;
                
                // Create rocket element using pool
                this.rocketEl = elementPool.get('^', 'rocket');
                this.rocketEl.style.color = this.color;
                viewport.appendChild(this.rocketEl);
            }
            
            update(dt = 1) {
                if (this.phase === 'launch') {
                    // Minecraft-inspired physics (toned down)
                    // Horizontal acceleration: slight increase each tick (creates gentle arc)
                    this.vx *= Math.pow(1.02, dt);
                    // Vertical acceleration: add constant upward boost (like thrust)
                    this.vy += 0.04 * dt;
                    
                    // Update position
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    
                    // Add trail (less frequently)
                    if (Math.random() > 0.5) {
                        const trailEl = elementPool.get(Math.random() > 0.5 ? '|' : '!', 'particle');
                        trailEl.style.color = Math.random() > 0.5 ? '#ffcc66' : '#ffffff'; // Golden and white trail mix
                        viewport.appendChild(trailEl);
                        
                        this.trail.push({
                            x: this.x,
                            y: this.y,
                            life: 1.0,
                            element: trailEl
                        });
                    }
                    
                    // Update trail (scaled by dt)
                    this.trail = this.trail.filter(t => {
                        t.life -= 0.08 * dt;
                        if (t.life <= 0) {
                            if (t.element && t.element.parentNode) {
                                elementPool.release(t.element);
                            }
                            return false;
                        }
                        return true;
                    });
                    
                    // Check if reached target height (position-based explosion)
                    if (this.y <= this.targetY) {
                        this.explode();
                    }
                    
                } else if (this.phase === 'explode') {
                    // Update particles (scaled by dt)
                    this.particles.forEach(p => {
                        p.vx *= Math.pow(0.98, dt); // Air resistance
                        p.vy += (p.gravity || 0.05) * dt; // Much lighter gravity (realistic)
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        p.life -= 0.015 * dt; // Fade out faster (so they disappear in sky)
                        
                        // Palm trails: occasionally drop a trail particle
                        if (p.hasTrail && Math.random() > 0.7 && p.life > 0.5) {
                            const trailParticle = {
                                x: p.x,
                                y: p.y,
                                vx: 0,
                                vy: 1,
                                life: 0.5,
                                char: 'Â·',
                                gravity: 0.1,
                                element: elementPool.get('Â·', 'particle')
                            };
                            trailParticle.element.style.color = this.color;
                            viewport.appendChild(trailParticle.element);
                            this.particles.push(trailParticle);
                        }
                    });
                    
                    // Remove dead particles or particles outside viewport bounds
                    const viewportHeight = viewport.clientHeight;
                    const viewportWidth = viewport.clientWidth;
                    this.particles = this.particles.filter(p => {
                        const outOfBounds = p.y > viewportHeight + 50 || p.y < -50 || 
                                          p.x > viewportWidth + 50 || p.x < -50;
                        if (outOfBounds || p.life <= 0) {
                            // Return element to pool
                            if (p.element && p.element.parentNode) {
                                elementPool.release(p.element);
                            }
                            return false;
                        }
                        return true;
                    });
                    
                    // Check if all particles are dead
                    if (this.particles.length === 0) {
                        this.dead = true;
                    }
                }
            }
            
            explode() {
                this.phase = 'explode';
                this.exploded = true;
                
                // Remove rocket element
                if (this.rocketEl && this.rocketEl.parentNode) {
                    this.rocketEl.parentNode.removeChild(this.rocketEl);
                }
                
                // Clear all trail elements immediately
                this.trail.forEach(t => {
                    if (t.element && t.element.parentNode) {
                        elementPool.release(t.element);
                    }
                });
                this.trail = [];
                
                // Create particles based on explosion type
                const chars = ['*', '+', 'Â·', 'o', 'Â°', 'âœ§', 'Ã—', 'â€¢'];
                let particleCount;
                
                if (this.explosionType === 'peony') {
                    // Standard spherical burst
                    particleCount = Math.random() * 20 + 30;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = Math.random() * 4 + 2;
                        this.createParticle(angle, speed, chars, this.color);
                    }
                    
                } else if (this.explosionType === 'ring') {
                    // Ring shape - expanding circle with less vertical spread
                    particleCount = Math.random() * 30 + 40;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = Math.random() * 3 + 4;
                        // Compress vertical component to create flatter ring
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed * 0.3; // 30% vertical speed
                        
                        const particle = {
                            x: this.x,
                            y: this.y,
                            vx: vx,
                            vy: vy,
                            life: 1.0,
                            char: chars[Math.floor(Math.random() * chars.length)],
                            gravity: 0.05, // Light gravity for ring
                            hasTrail: false,
                            element: null
                        };
                        
                        particle.element = elementPool.get(particle.char, 'particle');
                        particle.element.style.color = this.color;
                        viewport.appendChild(particle.element);
                        this.particles.push(particle);
                    }
                    
                } else if (this.explosionType === 'willow') {
                    // Willow - upward burst with heavier gravity (droop effect, but still realistic)
                    particleCount = Math.random() * 40 + 50;
                    for (let i = 0; i < particleCount; i++) {
                        // Full circle distribution
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = Math.random() * 4 + 3;
                        const particle = this.createParticle(angle, speed, ['|', '/', '\\', '!', '*'], this.color);
                        particle.gravity = 0.12; // Slightly more gravity for droop, but still light
                    }
                    
                } else if (this.explosionType === 'palm') {
                    // Palm - thick trails going outward and up
                    particleCount = 12;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount - Math.PI / 4;
                        const speed = Math.random() * 2 + 5;
                        const particle = this.createParticle(angle, speed, ['*', 'âœ§', '+'], this.color);
                        particle.hasTrail = true; // Will leave trail particles
                    }
                }
            }
            
            createParticle(angle, speed, chars, color) {
                const particle = {
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    char: chars[Math.floor(Math.random() * chars.length)],
                    gravity: 0.05, // Light default gravity (realistic)
                    hasTrail: false,
                    element: null
                };
                
                // Create particle element using pool
                particle.element = elementPool.get(particle.char, 'particle');
                particle.element.style.color = color;
                viewport.appendChild(particle.element);
                
                this.particles.push(particle);
                return particle;
            }
            
            render() {
                if (this.phase === 'launch') {
                    // Render rocket using transform
                    if (this.rocketEl) {
                        this.rocketEl.style.transform = `translate3d(${this.x}px, ${this.y}px, 0)`;
                    }
                    
                    // Render trail using transform
                    this.trail.forEach(t => {
                        if (t.element) {
                            t.element.style.transform = `translate3d(${t.x}px, ${t.y}px, 0)`;
                            t.element.style.opacity = t.life;
                        }
                    });
                    
                } else if (this.phase === 'explode') {
                    // Render particles using transform
                    this.particles.forEach(p => {
                        if (p.element) {
                            p.element.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
                            p.element.style.opacity = p.life;
                        }
                    });
                }
            }
            
            cleanup() {
                // Return rocket element to pool
                if (this.rocketEl && this.rocketEl.parentNode) {
                    elementPool.release(this.rocketEl);
                }
                
                // Return all trail elements to pool
                this.trail.forEach(t => {
                    if (t.element && t.element.parentNode) {
                        elementPool.release(t.element);
                    }
                });
                
                // Return all particle elements to pool
                this.particles.forEach(p => {
                    if (p.element && p.element.parentNode) {
                        elementPool.release(p.element);
                    }
                });
            }
        }
        
        function launchFirework(explosionType = null, color = null) {
            const startX = Math.random() * (viewport.clientWidth - 100) + 50;
            const firework = new Firework(startX, explosionType, color);
            fireworks.push(firework);
            fireworkCount++;
            countDisplay.textContent = fireworkCount;
            
            // Start animation loop if not running
            if (!animationId) {
                animate();
            }
        }
        
        function animate(ts) {
            // Calculate delta time (capped at 4x for stability)
            const dt = Math.min((ts - lastTs) / 16.6667, 4);
            lastTs = ts;
            
            // Update all fireworks with delta time
            fireworks.forEach(fw => fw.update(dt));
            
            // Render all fireworks
            fireworks.forEach(fw => fw.render());
            
            // Remove dead fireworks
            fireworks = fireworks.filter(fw => {
                if (fw.dead) {
                    fw.cleanup();
                    return false;
                }
                return true;
            });
            
            // Continue animation if there are active fireworks
            if (fireworks.length > 0) {
                animationId = requestAnimationFrame(animate);
            } else {
                animationId = null;
            }
        }
        
        // Event listeners
        launchBtn.addEventListener('click', launchFirework);
        
        // Optional: Launch with spacebar
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                launchFirework();
            }
        });
        
        // Optional: Launch a few fireworks on load for demo
        setTimeout(() => launchFirework(), 500);
        setTimeout(() => launchFirework(), 800);
        setTimeout(() => launchFirework(), 1100);
    </script>
</body>
</html>