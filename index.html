<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Patakhe! üß®</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Amita:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            touch-action: manipulation; /* Prevent double-tap zoom on mobile */
        }
        
        #viewport {
            position: relative;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            user-select: none;
            font-size: 14px;
            line-height: 1;
            will-change: transform, opacity;
        }
        
        .rocket {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            user-select: none;
            font-size: 16px;
            line-height: 1;
            will-change: transform, opacity;
        }
        
        @media (min-width: 768px) {
            .particle {
                font-size: 18px;
            }
            
            .rocket {
                font-size: 20px;
            }
        }
        
        .star {
            position: absolute;
            color: white;
            pointer-events: none;
            user-select: none;
            font-size: 12px;
            animation: twinkle 3s ease-in-out infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        #launchBtn {
            background: radial-gradient(circle at center, #f6f0c2, #e8df9c);
        }
        
        #launchBtn:hover {
            transform: scale(1.00);
            background: radial-gradient(circle at center, #f6f0c2, #e8df9c);
        }
        
        #launchBtn:active {
            transform: scale(0.95);
        }
        
        .diwali-greeting {
            font-family: 'Amita', cursive;
            font-size: 20px;
            font-weight: 700;
            color: #d4a574;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
        }
        
        .divider {
            width: 2px;
            height: 60px;
            background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.3), transparent);
        }
        
        @media (min-width: 768px) {
            .divider {
                height: 80px;
            }
        }
        
        .stats-section {
            text-align: right;
        }
        
        .stat-label {
            color: #888;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }
        
        .stat-value {
            color: white;
            font-size: 16px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        
        @media (min-width: 768px) {
            .stat-label {
                font-size: 11px;
                letter-spacing: 1px;
                margin-bottom: 4px;
            }
            
            .stat-value {
                font-size: 20px;
            }
        }
        
        .tooltip {
            color: #888;
            font-size: 12px;
            margin-top: 8px;
        }
        
        .attribution {
            color: #999;
            font-size: 13px;
            margin-top: 12px;
        }
        
        .share-button {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: #1DA1F2;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 12px;
            transition: all 0.2s;
            margin-top: 8px;
        }
        
        .share-button:hover {
            background: #1a8cd8;
            transform: scale(1.05);
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        @media (min-width: 768px) {
            .connection-status {
                top: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 12px;
                gap: 8px;
            }
        }
        
        .connection-status.connected {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        
        .connection-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .connection-status.connecting {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #launchBtn {
            transition: opacity 0.1s ease, transform 0.2s ease;
        }
    </style>
</head>
<body class="flex flex-col min-h-screen pb-4 md:pb-8" style="background-image: url('background.png'); background-size: repeat; background-position: center;">
    <!-- Connection Status Badge -->
    <div id="connectionStatus" class="connection-status connecting">
        <div class="status-dot"></div>
        <span id="connectionText">Connecting...</span>
    </div>
    
    <!-- Fireworks Viewport (Full Screen) -->
    <div id="viewport" class="flex-1 bg-black relative rounded-b-[30px] md:rounded-b-[50px] overflow-hidden mb-4 md:mb-8">
    </div>
    
    <!-- Bottom Control Panel -->
    <div class="px-4 md:px-8 py-6 md:py-8 flex flex-col md:flex-row items-center justify-center w-full gap-4 md:gap-6">
        <!-- Left: Greetings -->
        <div class="flex-1 text-center w-full md:w-auto">
            <div class="diwali-greeting">
                ü™î Happy Diwali ü™î<br>‚ú® ‡§∂‡•Å‡§≠ ‡§¶‡•Ä‡§™‡§æ‡§µ‡§≤‡•Ä ‚ú®
            </div>
            <div class="attribution text-xs md:text-sm">From <a href="https://x.com/siphyshu" target="_blank" class="text-blue-500">@siphyshu</a> with üíñ</div>
        </div>
        
        <!-- Divider (hidden on mobile) -->
        <div class="divider hidden md:block"></div>
        
        <!-- Center: Launch Button -->
        <div class="flex flex-col items-center flex-1 gap-2 w-full md:w-auto">
            <button id="launchBtn" class="px-8 md:px-10 py-3 md:py-4 text-black font-bold text-base md:text-lg transition-all duration-200 cursor-pointer rounded-lg w-full md:w-auto max-w-xs">
                Launch Patakha!
            </button>
            <div class="tooltip text-xs md:text-sm hidden md:block">Press [Space] to Launch</div>
        </div>
        
        <!-- Divider (hidden on mobile) -->
        <div class="divider hidden md:block"></div>
        
        <!-- Right: Stats Section -->
        <div class="flex flex-row items-center justify-center gap-4 md:gap-8 flex-1 w-full md:w-auto">
            <div class="stats-section text-center">
                <div class="stat-label">Patakhe Launched</div>
                <div class="stat-value" id="count">0</div>
            </div>
            <div class="stats-section text-center">
                <div class="stat-label">Patakhe Rate</div>
                <div class="stat-value" id="rateCount">0/sec</div>
            </div>
            <div class="stats-section text-center">
                <div class="stat-label">Online</div>
                <div class="stat-value" id="onlineCount">1</div>
            </div>
        </div>
    </div>

    <script>
        const viewport = document.getElementById('viewport');
        const launchBtn = document.getElementById('launchBtn');
        const countDisplay = document.getElementById('count');
        const rateDisplay = document.getElementById('rateCount');
        const onlineDisplay = document.getElementById('onlineCount');
        const connectionStatus = document.getElementById('connectionStatus');
        const connectionText = document.getElementById('connectionText');
        
        let fireworks = [];
        let animationId = null;
        let lastTs = performance.now();
        let ws = null;
        let reconnectTimeout = null;
        let isButtonOnCooldown = false;
        let reconnectAttempts = 0;
        let maxReconnectDelay = 30000; // Max 30 seconds between attempts
        
        // Create twinkling stars
        function createStars() {
            const starCount = 100;
            const starChars = ['.', '*', '¬∑', '¬∞', '+'];
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = starChars[Math.floor(Math.random() * starChars.length)];
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 80 + '%'; // Keep in top 80% of screen
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                viewport.appendChild(star);
            }
        }
        
        createStars();
        
        // DOM element pool for performance
        const elementPool = {
            pool: [],
            maxSize: 300,
            get(char, cls) {
                const el = this.pool.pop() || document.createElement('div');
                el.className = cls || 'particle';
                el.textContent = char;
                el.style.display = '';
                // Reset transform and opacity for reused elements
                el.style.transform = '';
                el.style.opacity = '1';
                return el;
            },
            release(el) {
                if (this.pool.length < this.maxSize) {
                    el.style.display = 'none';
                    this.pool.push(el);
                } else {
                    // Pool full, actually remove
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                }
            }
        };
        
        const colors = [
            '#ff0066', // hot pink (vivid)
            '#ffcc00', // bright gold (Diwali)
            '#ff6600', // deep orange (warm)
            '#ff3333', // bright red (classic)
            '#00ffff', // cyan (vivid)
            '#9966ff', // purple (classic firework)
            '#ffffff', // pure white
            '#ff9900', // amber (warm)
            '#66ffcc', // mint (vivid)
            '#ffdd00', // golden yellow (Diwali)
        ];
        
        class Firework {
            constructor(startX, explosionType = null, color = null) {
                this.id = Date.now() + Math.random();
                this.startX = startX;
                this.x = startX;
                this.y = viewport.clientHeight;
                
                // Minecraft-inspired physics
                this.vy = -9; // Initial vertical velocity (upward, faster now)
                this.vx = (Math.random() - 0.5) * 0.4; // Small random horizontal velocity
                
                // Target explosion height (position-based, relative to viewport)
                const explosionHeightPercent = Math.random() * 0.25 + 0.10; // Explode at 10-35% from top
                this.targetY = viewport.clientHeight * explosionHeightPercent;
                this.color = color || colors[Math.floor(Math.random() * colors.length)];
                
                // Choose explosion type (can be overridden by debug panel)
                this.explosionType = explosionType || ['peony', 'palm'][Math.floor(Math.random() * 2)];
                
                this.phase = 'launch'; // 'launch' or 'explode'
                this.particles = [];
                this.trail = [];
                this.trailElements = []; // Store trail elements for reuse
                this.exploded = false;
                this.dead = false;
                
                // Create rocket element using pool
                this.rocketEl = elementPool.get('^', 'rocket');
                this.rocketEl.style.color = this.color;
                viewport.appendChild(this.rocketEl);
            }
            
            update(dt = 1) {
                if (this.phase === 'launch') {
                    // Minecraft-inspired physics (toned down)
                    // Horizontal acceleration: slight increase each tick (creates gentle arc)
                    this.vx *= Math.pow(1.02, dt);
                    // Vertical acceleration: add constant upward boost (like thrust)
                    this.vy += 0.04 * dt;
                    
                    // Update position
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    
                    // Add trail (less frequently)
                    if (Math.random() > 0.5) {
                        const trailEl = elementPool.get(Math.random() > 0.5 ? '|' : '!', 'particle');
                        trailEl.style.color = Math.random() > 0.5 ? '#ffcc66' : '#ffffff'; // Golden and white trail mix
                        viewport.appendChild(trailEl);
                        
                        this.trail.push({
                            x: this.x,
                            y: this.y,
                            life: 1.0,
                            element: trailEl
                        });
                    }
                    
                    // Update trail (scaled by dt)
                    this.trail = this.trail.filter(t => {
                        t.life -= 0.08 * dt;
                        if (t.life <= 0) {
                            if (t.element && t.element.parentNode) {
                                elementPool.release(t.element);
                            }
                            return false;
                        }
                        return true;
                    });
                    
                    // Check if reached target height (position-based explosion)
                    if (this.y <= this.targetY) {
                        this.explode();
                    }
                    
                } else if (this.phase === 'explode') {
                    // Update particles (scaled by dt)
                    this.particles.forEach(p => {
                        p.vx *= Math.pow(0.98, dt); // Air resistance
                        p.vy += (p.gravity || 0.05) * dt; // Much lighter gravity (realistic)
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        p.life -= 0.015 * dt; // Fade out faster (so they disappear in sky)
                        
                        // Palm trails: occasionally drop a trail particle
                        if (p.hasTrail && Math.random() > 0.7 && p.life > 0.5) {
                            const trailParticle = {
                                x: p.x,
                                y: p.y,
                                vx: 0,
                                vy: 1,
                                life: 0.5,
                                char: '¬∑',
                                gravity: 0.1,
                                element: elementPool.get('¬∑', 'particle')
                            };
                            trailParticle.element.style.color = this.color;
                            viewport.appendChild(trailParticle.element);
                            this.particles.push(trailParticle);
                        }
                    });
                    
                    // Remove dead particles or particles outside viewport bounds
                    const viewportHeight = viewport.clientHeight;
                    const viewportWidth = viewport.clientWidth;
                    this.particles = this.particles.filter(p => {
                        const outOfBounds = p.y > viewportHeight + 50 || p.y < -50 || 
                                          p.x > viewportWidth + 50 || p.x < -50;
                        if (outOfBounds || p.life <= 0) {
                            // Return element to pool
                            if (p.element && p.element.parentNode) {
                                elementPool.release(p.element);
                            }
                            return false;
                        }
                        return true;
                    });
                    
                    // Check if all particles are dead
                    if (this.particles.length === 0) {
                        this.dead = true;
                    }
                }
            }
            
            explode() {
                this.phase = 'explode';
                this.exploded = true;
                
                // Remove rocket element
                if (this.rocketEl && this.rocketEl.parentNode) {
                    this.rocketEl.parentNode.removeChild(this.rocketEl);
                }
                
                // Clear all trail elements immediately
                this.trail.forEach(t => {
                    if (t.element && t.element.parentNode) {
                        elementPool.release(t.element);
                    }
                });
                this.trail = [];
                
                // Create particles based on explosion type
                const chars = ['*', '+', '¬∑', 'o', '¬∞', '‚úß', '√ó', '‚Ä¢'];
                let particleCount;
                
                if (this.explosionType === 'peony') {
                    // Standard spherical burst
                    particleCount = Math.random() * 20 + 30;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const speed = Math.random() * 4 + 2;
                        this.createParticle(angle, speed, chars, this.color);
                    }
                    
                } else if (this.explosionType === 'ring') {
                    // Ring shape - expanding circle with less vertical spread
                    particleCount = Math.random() * 30 + 40;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = Math.random() * 3 + 4;
                        // Compress vertical component to create flatter ring
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed * 0.3; // 30% vertical speed
                        
                        const particle = {
                            x: this.x,
                            y: this.y,
                            vx: vx,
                            vy: vy,
                            life: 1.0,
                            char: chars[Math.floor(Math.random() * chars.length)],
                            gravity: 0.05, // Light gravity for ring
                            hasTrail: false,
                            element: null
                        };
                        
                        particle.element = elementPool.get(particle.char, 'particle');
                        particle.element.style.color = this.color;
                        viewport.appendChild(particle.element);
                        this.particles.push(particle);
                    }
                    
                } else if (this.explosionType === 'willow') {
                    // Willow - upward burst with heavier gravity (droop effect, but still realistic)
                    particleCount = Math.random() * 40 + 50;
                    for (let i = 0; i < particleCount; i++) {
                        // Full circle distribution
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const speed = Math.random() * 4 + 3;
                        const particle = this.createParticle(angle, speed, ['|', '/', '\\', '!', '*'], this.color);
                        particle.gravity = 0.12; // Slightly more gravity for droop, but still light
                    }
                    
                } else if (this.explosionType === 'palm') {
                    // Palm - thick trails going outward and up
                    particleCount = 12;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount - Math.PI / 4;
                        const speed = Math.random() * 2 + 5;
                        const particle = this.createParticle(angle, speed, ['*', '‚úß', '+'], this.color);
                        particle.hasTrail = true; // Will leave trail particles
                    }
                }
            }
            
            createParticle(angle, speed, chars, color) {
                    const particle = {
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        char: chars[Math.floor(Math.random() * chars.length)],
                    gravity: 0.05, // Light default gravity (realistic)
                    hasTrail: false,
                        element: null
                    };
                    
                    // Create particle element using pool
                    particle.element = elementPool.get(particle.char, 'particle');
                particle.element.style.color = color;
                    viewport.appendChild(particle.element);
                    
                    this.particles.push(particle);
                return particle;
            }
            
            render() {
                if (this.phase === 'launch') {
                    // Render rocket using transform
                    if (this.rocketEl) {
                        this.rocketEl.style.transform = `translate3d(${this.x}px, ${this.y}px, 0)`;
                    }
                    
                    // Render trail using transform
                    this.trail.forEach(t => {
                        if (t.element) {
                            t.element.style.transform = `translate3d(${t.x}px, ${t.y}px, 0)`;
                            t.element.style.opacity = t.life;
                        }
                    });
                    
                } else if (this.phase === 'explode') {
                    // Render particles using transform
                    this.particles.forEach(p => {
                        if (p.element) {
                            p.element.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
                            p.element.style.opacity = p.life;
                        }
                    });
                }
            }
            
            cleanup() {
                // Return rocket element to pool
                if (this.rocketEl && this.rocketEl.parentNode) {
                    elementPool.release(this.rocketEl);
                }
                
                // Return all trail elements to pool
                this.trail.forEach(t => {
                    if (t.element && t.element.parentNode) {
                        elementPool.release(t.element);
                    }
                });
                
                // Return all particle elements to pool
                this.particles.forEach(p => {
                    if (p.element && p.element.parentNode) {
                        elementPool.release(p.element);
                    }
                });
            }
        }
        
        function launchFirework(xPercent = null, explosionType = null, color = null) {
            // Calculate x position from percentage (or random if not provided)
            let startX;
            if (xPercent !== null) {
                startX = xPercent * viewport.clientWidth;
            } else {
                startX = Math.random() * (viewport.clientWidth - 100) + 50;
            }
            
            const firework = new Firework(startX, explosionType, color);
            fireworks.push(firework);
            
            // Start animation loop if not running
            if (!animationId) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // WebSocket connection management
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            console.log('üîå Attempting WebSocket connection to:', wsUrl);
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('‚úÖ Connected to server');
                connectionStatus.className = 'connection-status connected';
                connectionText.textContent = 'Connected';
                clearTimeout(reconnectTimeout);
                
                // Reset reconnection backoff on successful connection
                reconnectAttempts = 0;
                
                // Reset local counter when successfully connected to server
                // Server will send us the real count via stats message
                localFireworkCount = 0;
            };
            
            ws.onmessage = (event) => {
                console.log('üì® Received message:', event.data);
                const data = JSON.parse(event.data);
                
                if (data.type === 'firework') {
                    console.log('üéÜ Firework event:', data);
                    // Launch firework at position from server
                    launchFirework(data.x);
                    // Update counter
                    countDisplay.textContent = formatNumber(data.count);
                } else if (data.type === 'count_update') {
                    console.log('üî¢ Count update:', data);
                    // Just update counter (sampled out firework)
                    countDisplay.textContent = formatNumber(data.count);
                } else if (data.type === 'stats') {
                    console.log('üìä Stats update:', data);
                    // Update all statistics
                    countDisplay.textContent = formatNumber(data.total);
                    // Rate is already per-second from backend
                    rateDisplay.textContent = `${data.rate.toFixed(1)}/sec`;
                    onlineDisplay.textContent = formatNumber(data.online);
                } else if (data.type === 'cooldown') {
                    console.log('‚è±Ô∏è Rate limited:', data.message);
                }
            };
            
            ws.onerror = (error) => {
                console.error('‚ùå WebSocket error:', error);
                console.error('Error details:', {
                    readyState: ws.readyState,
                    url: ws.url
                });
                
                // Set to offline mode on error
                connectionStatus.className = 'connection-status disconnected';
                connectionText.textContent = 'Disconnected';
                
                // Enable the button for offline mode
                isButtonOnCooldown = false;
                launchBtn.style.opacity = '1';
            };
            
            ws.onclose = (event) => {
                console.log('üîå Disconnected from server');
                console.log('Close event:', {
                    code: event.code,
                    reason: event.reason,
                    wasClean: event.wasClean
                });
                connectionStatus.className = 'connection-status disconnected';
                connectionText.textContent = 'Disconnected';
                
                // Update stats for offline mode (but keep local counter)
                rateDisplay.textContent = '-';
                onlineDisplay.textContent = '-';
                
                // If this is the first disconnect and we haven't launched anything locally yet
                if (localFireworkCount === 0) {
                    countDisplay.textContent = '0';
                }
                // Otherwise keep showing the local count
                
                // Enable the button for offline mode
                isButtonOnCooldown = false;
                launchBtn.style.opacity = '1';
                
                // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), maxReconnectDelay);
                
                console.log(`‚è±Ô∏è Reconnecting in ${delay/1000}s (attempt ${reconnectAttempts})`);
                
                // Attempt to reconnect with exponential backoff
                reconnectTimeout = setTimeout(() => {
                    connectionStatus.className = 'connection-status connecting';
                    connectionText.textContent = 'Reconnecting...';
                    connectWebSocket();
                }, delay);
            };
        }
        
        // Local firework counter for offline mode
        let localFireworkCount = 0;
        
        // Format large numbers with K, M, B suffixes
        function formatNumber(num) {
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'B';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            }
            return num.toLocaleString();
        }
        
        // Send launch request to server
        function requestLaunch() {
            console.log('üöÄ Launch requested, WebSocket state:', ws ? ws.readyState : 'null');
            
            // Check cooldown first - prevent any action during cooldown
            if (isButtonOnCooldown) {
                console.log('‚è±Ô∏è Button on cooldown - ignoring click');
                return;
            }
            
            // Apply cooldown immediately to prevent rapid clicks
            isButtonOnCooldown = true;
            launchBtn.style.opacity = '0.6';
            
            // Check if connected to server
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.log('‚ö†Ô∏è Not connected to server - launching locally');
                // Launch firework locally in offline mode
                launchFirework();
                localFireworkCount++;
                countDisplay.textContent = formatNumber(localFireworkCount);
                
                // Reset cooldown after delay
                setTimeout(() => {
                    isButtonOnCooldown = false;
                    launchBtn.style.opacity = '1';
                }, 300);
                
                return;
            }
            
            // Connected - send to server
            const message = {
                type: 'launch',
                timestamp: Date.now()
            };
            
            console.log('üì§ Sending message:', message);
            ws.send(JSON.stringify(message));
            
            // Reset cooldown after delay
            setTimeout(() => {
                isButtonOnCooldown = false;
                launchBtn.style.opacity = '1';
            }, 300);
        }
        
        function animate(ts) {
            // Calculate delta time (capped at 4x for stability)
            const dt = Math.min((ts - lastTs) / 16.6667, 4);
            lastTs = ts;
            
            // Update all fireworks with delta time
            fireworks.forEach(fw => fw.update(dt));
            
            // Render all fireworks
            fireworks.forEach(fw => fw.render());
            
            // Remove dead fireworks
            fireworks = fireworks.filter(fw => {
                if (fw.dead) {
                    fw.cleanup();
                    return false;
                }
                return true;
            });
            
            // Continue animation if there are active fireworks
            if (fireworks.length > 0) {
                animationId = requestAnimationFrame(animate);
            } else {
                animationId = null;
            }
        }
        
        // Event listeners
        launchBtn.addEventListener('click', requestLaunch);
        
        // Track if space is already pressed to prevent repeat firing
        let spacePressed = false;
        
        // Launch with spacebar (only once per press)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                requestLaunch();
            }
        });
        
        // Reset when space is released
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
            }
        });
        
        // Initialize WebSocket connection
        connectWebSocket();
    </script>
</body>
</html>